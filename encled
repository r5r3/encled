#!/usr/bin/env python3
"""
encled - SCSI Enclosure indicators (SES LED) control
"""
import argparse
import logging
import subprocess
import re
import os
import numpy

CLASS = '/sys/class/enclosure/'
SLOT = 'Slot '  # with space

# define layouts for enclosures
enclosure_layouts = {"sm24": numpy.array([[6, 12, 18, 24],
                                          [5, 11, 17, 23],
                                          [4, 10, 16, 22],
                                          [3, 9, 15, 21],
                                          [2, 8, 14, 20],
                                          [1, 7, 13, 19]]),
                     "sm44": numpy.array([[6, 12, 18, 24],
                                          [5, 11, 17, 23],
                                          [4, 10, 16, 22],
                                          [3, 9, 15, 21],
                                          [2, 8, 14, 20],
                                          [1, 7, 13, 19],
                                          [0, 32, 38, 44],
                                          [0, 31, 37, 43],
                                          [0, 30, 36, 42],
                                          [0, 29, 35, 41],
                                          [26, 28, 34, 40],
                                          [25, 27, 33, 39]])}


def error(text):
    """
    cancel the operation and exit
    :param text:
    :return:
    """
    logging.error(text)
    exit(-1)


def scan_system():
    """
    use lsscsi, sg_ses to get an overview of the system
    :return:
    """
    # first step: use lsscsi to find all enclosures
    enclosures = {}
    sts, out = subprocess.getstatusoutput("lsscsi -g")
    if sts != 0:
        error("unable to list scsi devices!")
    for line in out.splitlines():
        words = line.split()
        if words[1] == "enclosu":
            enclosures[words[-1]] = {"scsi_tuple": words[0][1:-1]}

    # create a mapping between the /dev/sd* devices and sas addresses
    sas_dev_sd = {}
    dev_sd_scsi = {}
    sts, out = subprocess.getstatusoutput("lsscsi -t -i")
    if sts != 0:
        error("unable to list scsi devices!")
    for line in out.splitlines():
        words = line.split()
        if words[1] == "disk" and words[2].startswith("sas:"):
            sas_dev_sd[words[2].replace("sas:", "")] = words[-2]
            dev_sd_scsi[words[-2]] = words[-1]

    # loop over all enclosures to find all connected devices
    for one_enclosure in enclosures.keys():
        sts, out = subprocess.getstatusoutput("sg_ses -p 0xa %s" % one_enclosure)
        if sts != 0:
            error("unable to find connected devices for enclosure %s" % one_enclosure)
        lines = out.splitlines()
        # the first line is the enclosure name
        enclosures[one_enclosure]["description"] = re.sub("\s+", ", ", lines[0].strip())
        # then find all disks, they start with "Element index:"
        enclosures[one_enclosure]["disks"] = {}
        in_device_slots = False
        for iline, line in enumerate(lines):
            if "Element type: " in line:
                in_device_slots = "Array device slot" in line
            if not in_device_slots:
                continue
            if line.strip().startswith("Element index:"):
                # find slot number and SAS-Address of this device
                current_line = iline+1
                new_dev = {"slot": None, "sas_address": None}
                while not "Element index:" in lines[current_line]:
                    m = re.search("device slot number: (\d+)", lines[current_line])
                    if m is not None:
                        new_dev["slot"] = int(m.group(1)) + 1
                        new_dev["path"] = find_path(enclosures[one_enclosure]["scsi_tuple"], new_dev["slot"])
                        new_dev["fault"] = int(get_file_content(os.path.join(new_dev["path"], "fault")))
                        new_dev["locate"] = int(get_file_content(os.path.join(new_dev["path"], "locate")))
                        new_dev["status"] = get_file_content(os.path.join(new_dev["path"], "status"))
                    m = re.search("^SAS address: (\w+)", lines[current_line].strip())
                    if m is not None:
                        new_dev["sas_address"] = m.group(1)
                        new_dev["dev_sd"] = sas_dev_sd[new_dev["sas_address"]]
                        new_dev["scsi_id"] = dev_sd_scsi[new_dev["dev_sd"]]
                    current_line += 1
                # store the disk by slot, /dev/sd* and scsi_id
                enclosures[one_enclosure]["disks"][new_dev["slot"]] = new_dev
                enclosures[one_enclosure]["disks"][new_dev["dev_sd"]] = new_dev
                enclosures[one_enclosure]["disks"][new_dev["scsi_id"]] = new_dev
    return enclosures


def find_path(enc, slot):
    """
    find the full path to the slot folder
    :param enc:     scsi_tuple of the enclosure
    :param slot:    number of the enclosure (starts with 1)
    :return:        full path, or None
    """
    name = str(slot)
    if os.path.isfile(os.path.join(CLASS, enc, name, 'type')):
        return os.path.join(CLASS, enc, name)
    for z in range(0, 4):
        if os.path.isfile(os.path.join(CLASS, enc, SLOT + name, 'type')):  # naming type 'Slot 01'
            return os.path.join(CLASS, enc, SLOT + name)
        if os.path.isfile(os.path.join(CLASS, enc, name, 'type')):  # naming type '001'
            return os.path.join(CLASS, enc, name)
        name = '0' + name  # try same name with more zeroes at front
    return None


def get_file_content(path):
    """
    read the content of a file
    :param path:
    :return:
    """
    try:
        with open(path) as f:
            return f.read().strip()
    except IOError:
        error("unable to read file %s" % path)


def find_disk(enclosures, key):
    """
    find a disk by a slot, a /dev/sd-name, or a scsi_id
    :param enclosures:  enclosure structure created by scan_system
    :param key:         slot, /dev/sd-name, or scsi_id
    :return:
    """
    for enc_dev in sorted(enclosures.keys()):
        one_enc = enclosures[enc_dev]
        if key in one_enc["disks"]:
            result = one_enc["disks"][key]
            result["enclosure"] = enc_dev
            return result
    return None


def cat_text_blocks(blocks, width=20, lines=3):
    """
    take multiline textblocks and concatinate them. Each block is a string with line breaks.
    """
    def splitlines(text):
        result = text.splitlines()
        while len(result) < lines:
            result.append("-")
        return result

    blocks_in_lines = map(lambda x: splitlines(x), blocks)
    result = []
    for one_block in blocks_in_lines:
        for i, line in enumerate(one_block):
            if i >= len(result):
                result.append("")
            result[i] += ("%%-%ds" % width) % line
    return "\n".join(result)


def get_status_block_for_disk(one_disk):
    """
    returns a formatted text block for one disk
    :param disk:    disk-dictionary created by scan_system
    :return:
    """
    block = "Slot %d: %s\n" % (one_disk["slot"], one_disk["dev_sd"])
    block += "%s\n" % one_disk["scsi_id"]
    block += "Status=%s L=%d F=%d" % (one_disk["status"], one_disk["locate"], one_disk["fault"])
    return block


def set_single_disk_led(disk, status):
    """
    turn leds for disks on and off
    :param disk:    the disk-dictionary from scan_system
    :param status:  "locate", "fault", or "off"
    :return:
    """
    if status == 'fault':
        with open(os.path.join(disk["path"], 'locate'), 'w') as f:
            f.write('0')
        with open(os.path.join(disk["path"], 'fault'), 'w') as f:
            f.write('1')
    elif status == 'locate':
        with open(os.path.join(disk["path"], 'fault'), 'w') as f:
            f.write('0')
        with open(os.path.join(disk["path"], 'locate'), 'w') as f:
            f.write('1')
    elif status == 'off':
        with open(os.path.join(disk["path"], 'locate'), 'w') as f:
            f.write('0')
        with open(os.path.join(disk["path"], 'fault'), 'w') as f:
            f.write('0')
    else:
        error("Wrong status (%s)" % status)


def set_leds(enclosures, arg_disk, status):
    """
    set for one or multiple disk the leds
    :param enclosures:  enclosure structure created by scan_system
    :param arg_disk:    disk-dictionary
    :param status:      "locate", "fault", or "off"
    :return:
    """
    # one disk, or everything?
    if arg_disk is not None:
        set_single_disk_led(arg_disk, status)
        return

    # loop over all enclosures
    for enc_dev in sorted(enclosures.keys()):
        one_enc = enclosures[enc_dev]
        # loop over all disks
        for one_disk_key in one_enc["disks"].keys():
            if type(one_disk_key) != int:
                continue
            set_single_disk_led(one_enc["disks"][one_disk_key], status)


def show_status(enclosures, arg_disk):
    """
    create a formatted overview of the status
    :param enclosures:  enclosure structure created by scan_system
    :param arg_disk:    disk-dictionary
    :return:
    """
    # one disk, or everything?
    if arg_disk is not None:
        print("Enclosure: %s (%s)" % (enclosures[arg_disk["enclosure"]]["description"], arg_disk["enclosure"]))
        print(get_status_block_for_disk(arg_disk))
        return

    # loop over all enclosures
    for enc_dev in sorted(enclosures.keys()):
        one_enc = enclosures[enc_dev]
        print("\nEnclosure: %s (%s)" % (one_enc["description"], enc_dev))
        print("-" * 80)

        # create blocks of text for each slot
        max_slot = max([i for i in one_enc["disks"].keys() if type(i) == int])
        # guess the enclosure type from the number of disks
        if max_slot > 24:
            enc_type = "sm44"
        else:
            enc_type = "sm24"
        slot_blocks = numpy.empty(enclosure_layouts[enc_type].shape, dtype="U200")
        for slot in range(1,max_slot+1):
            if slot in one_enc["disks"]:
                slot_blocks[enclosure_layouts[enc_type] == slot] = get_status_block_for_disk(one_enc["disks"][slot])

        # arrange the blocks, six per row
        rows = slot_blocks.shape[0]
        for row in range(0, rows):
            print(cat_text_blocks(slot_blocks[row, :]))
            print()


def add_enc_disk_args(sp):
    sp.add_argument("-e", "--enc", help="the enclosure of interest.")
    sp.add_argument("-d", "--disk", help="the disk of interest.")


if __name__ == "__main__":
    # set default log level
    logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

    # parse command line arguments
    parser = argparse.ArgumentParser(description=__doc__)
    subparsers = parser.add_subparsers(dest='action', title='available operations')
    sp_status = subparsers.add_parser("status", help="show the status of enclosures or disks")
    sp_led = subparsers.add_parser("led", help="turn on/off the leds of a disk")
    sp_led.add_argument("status", choices=["locate", "fault", "off"], help="select the led to turn on/off.")
    add_enc_disk_args(sp_status)
    add_enc_disk_args(sp_led)
    args = parser.parse_args()

    # is an operation selected?
    if args.action is None:
        error("no operation selected!")

    # scan the system and create a mapping between device names and slots
    encs = scan_system()

    # check arguments
    if args.enc is not None:
        if args.enc not in encs:
            error("Enclosure '%s' not found!" % args.enc)
        else:
            # remove other enclosures from the system informations
            encs = {args.enc: encs[args.enc]}
    if args.disk is not None:
        disk_dev = find_disk(encs, args.disk)
        if disk_dev is None:
            error("Disk '%s' not found!" % args.disk)
        args.disk = disk_dev

    # perform requested operation
    if args.action == "status":
        show_status(encs, args.disk)
    if args.action == "led":
        set_leds(encs, args.disk, args.status)
